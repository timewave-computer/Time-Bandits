Time Bandits System Contract
v1.0 — Draft

## Introduction

This document defines the core invariants and operational guarantees of the Time Bandits system. It applies to:

- All programs executed by Time Bandits.
- All timelines observed or modified by Time Bandits.
- All time maps composed from multiple timelines.
- All resources managed within and across timelines.
- All zero-knowledge proofs (ZKPs) generated by Time Bandits to attest to correct program execution.

This contract defines the invariants Time Bandits must uphold, under what conditions they must hold, and what guarantees are explicitly out of scope (relying instead on underlying blockchain/timeline properties).

## Key Concepts

### 1. Timeline

A timeline is a logically independent ledger of causally ordered events, each of which modifies resources tracked on that timeline.

- A timeline may be a blockchain, layer 2 rollup, or local append-only event log.
- Timelines are sharded — each timeline defines its own isolated view of time and resources.
- Each timeline maintains its own time consistency guarantee (e.g., blocks in order, no double spends within the timeline).

### 2. Time Map

A time map is a composed view of multiple timelines selected by a program. It defines the scope of causal influence for the program.

- A time map may be fully disjoint (no shared resources) or partially overlapping (some shared tokens/contracts).
- Time maps have selective imports — only explicitly referenced timelines contribute to the map.

### 3. Program
A program is a causally ordered sequence of guarded effects acting over a specific time map. Programs are deployed by time travelers (off-chain or on-chain entities).

- Programs are deterministic and can be re-executed from the same time map to reach the same result.
- Programs may invoke cross-timeline effects if allowed by their declared time map.

### 4. Resources

A resource is any mutable object controlled by a timeline, such as:

- Token balances
- Escrow states
- Smart contract states
- Program-local states (execution markers)

## System Invariants

The following invariants must hold at all times, under the conditions specified.

### 1. Timeline Consistency Inheritance

Invariant: Every program inherits the causal consistency guarantees of each timeline it imports into its time map.

Condition: Applies whenever a program reads from or writes to a timeline.

What this means:

- If a timeline guarantees "no double spends," programs must inherit that.
- If a timeline has blocks with total order, programs must inherit that.

What this does NOT mean:

- Time Bandits does not attempt to "fix" the consistency of a broken timeline. If the underlying timeline breaks its guarantees, programs built on top inherit the breakage.

### 2. Cross-Timeline Isolation

Invariant: No program can observe or modify a timeline it does not explicitly import into its time map.

Condition: Applies at program deployment and during execution.

What this means:

- Programs only see the timelines they request.
- Timelines remain sovereign; programs cannot inject external events into them without permission.

### 3. Causal Execution Consistency

Invariant: A program must process effects in the order declared in the program definition, and each effect must pass its guard conditions using the time map as it exists at the time of evaluation.

Condition: Applies whenever a program step executes.

What this means:

- Time Bandits may NOT reorder program steps.
- Guards (e.g., balance checks) always reflect the latest visible state within the declared time map.

### 4. Resource Conservation

Invariant: No program can create or destroy resources unless explicitly allowed by its time map (e.g., token minting effects explicitly defined).

Condition: Applies to all token and escrow effects.

What this means:

- If the time map does not allow minting, no program can mint.
- All transfers must leave the system's total balance unchanged.

### 5. No Backwards Time Travel

Invariant: Once a program step has executed using some snapshot of the time map, it cannot observe an earlier state of the same timeline.

Condition: Applies within the same program instance.

What this means:

- Each program experiences each timeline as monotonic.

### 6. Proven Execution

Invariant: Every program execution produces a zero-knowledge proof attesting that:

- Each effect was applied only when its guard conditions were satisfied.
- Each effect modified resources exactly as defined.
- No external input (outside the declared time map) influenced execution. Condition: Applies to every program finalization.

What this means:

- Programs are verifiable off-chain.
- Program correctness can be verified without trusting the operators.

### 7. Program Immutability

Invariant: Once deployed, a program's structure (sequence of effects and guards) cannot change.

Condition: Applies after initial deployment.

What this means:

- Programs are append-only, not mutable contracts.

### 8. Operator Neutrality

Invariant: Program correctness does not depend on the honesty of the operator, only on:

- Timeline integrity (honest timelines).
- Soundness of the zero-knowledge proof system.
- Correct program definition. Condition: Applies under normal network operation (assuming liveness).

What this means:

- Operators provide liveness, not correctness.
- Program verification can be done by anyone.

### 9. Message-Driven Transitions

Invariant: Every program step transition must be accompanied by a message that:

- References the correct program ID and counter.
- Provides all required resources (exact match with MemoryContract).
- Provides proof of control (matching declared actor capability).
- Results in a new valid state (advances counter + updates memory).

Condition: Applies to every program step execution.

What this means:

- Programs cannot advance "magically" — only when explicitly authorized.
- Every step has full auditability (causal proof chain).
- Programs can be re-executed deterministically using the message log and initial state.

### 10. Asset Memory Encapsulation

Invariant: All assets referenced in a program must be imported into program memory via valid, verifiable asset-to-resource mapping processes. No program step may directly reference or transfer an asset. All operations must pass through program memory.

Condition: Applies to all asset-related operations in programs.

What this means:

- Assets must be properly mapped to program memory before use.
- Direct asset manipulation is prohibited.
- Program memory provides a consistent interface for all asset operations.

This establishes a critical separation of concerns:

| Concern | Resource (Internal) | Asset/Entity (External) |
| --- | --- | --- |
| Lifecycle | Created, moved, consumed within a program's memory | Exists independently on a timeline |
| Ownership | Assigned to a memory slot inside a program | Owned by an address on the timeline |
| Reference | Pointed to directly in program memory | Resolved via queries into the timeline |
| Identity | Scoped to the program's lifecycle | Persistent across all programs |
| Example | "Escrow Slot 1 holds 50 GoldCoin" | "GoldCoin exists on Ethereum timeline" |

This separation ensures that:
- Programs only touch resources (internal representations).
- Timelines own the actual assets (tokens, escrows, contracts).
- Program execution can be replayed by tracking resource flows, not timeline history.
- Programs prove they could move assets, but actual movement is timeline responsibility.
- A program can interact with multiple chains, even if they have wildly different asset models.
- Programs cannot secretly mint assets — they only get what the timeline confirms.

## Explicit Non-Goals (Out of Scope)

- Time Bandits does not "verify" the internal consistency of each timeline (this is the timeline's responsibility).
- Time Bandits does not enforce any economic policy — it only executes declared effects.
- Time Bandits does not automatically detect dishonest operators — only failing to produce a valid proof.

## Optional Guarantees (Future Consideration)

- Program composability (one program calling another) — planned but not required in v1.
- Cross-timeline atomicity (either all timelines update or none) — planned, but initial release will support only "best-effort cross-timeline consistency" (eventual).

| Invariant | Scope | When Enforced |
| --- | --- | --- |
| Timeline Consistency Inheritance | All programs | On every timeline interaction |
| Cross-Timeline Isolation | All programs | On import & runtime |
| Causal Execution Consistency | All programs | On every effect |
| Resource Conservation | Token/escrow programs | On every token/escrow effect |
| No Backwards Time Travel | All programs | During execution |
| Proven Execution | All programs | After completion |
| Program Immutability | All programs | After deployment |
| Operator Neutrality | Whole system | Always |
| Message-Driven Transitions | All programs | On every step execution |
| Asset Memory Encapsulation | All programs | On all asset operations |
